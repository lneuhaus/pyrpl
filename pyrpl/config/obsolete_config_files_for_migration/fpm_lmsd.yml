redpitaya:
  hostname: 10.214.1.9
  password: root
  user: root
  port: 2222
  frequency_correction: 0.9999802723463688
  #0.9999801526493788
  filename: fpga//red_pitaya.bin
  reloadfpga: true
  # autostart gui?
  gui: false #true
  monitor_server_name: monitor_server

general:
  # name of this device
  name: fpm_lmsd
  # level of logged information.
  # 'debug' outputs everything
  # 'infi' is default level
  # 'warning' only shows warnings and errors
  # 'error' only shows errors
  loglevel: warning
  # import CurveDB class from which module? if missing, it's pyrpl.curvedb
  #curvedb: pyrpl
  curvedb: pyinstruments

# most important section that defines how the lockbox understands the
# real-world system
model:
  # use class Interferometer for internal model and lock algorithms
  # upper- or lowercase spelling is accepted if there is no ambiguity
  modeltype: FPM_LMSD
  # only needed parameter is wavelength
  # (to convert piezo displacement into gain)
  wavelength: 1.064e-06
  # maximum tolerated error of the internal variable
  # for interferometer, this is the phase error in radians
  # this value is uniquely needed for the function 'islocked'
  maxerror: 0.1
  offresonant_reflection: 0.3318003788590431
  resonant_reflection: 0.11915389448404312
  finesse: 92000.0
  length: 5.61e-05
  # signals in order of their preferrence
  #signalpreference:
  #- reflection
  #- transmission
  lock:
    error_threshold: 1
    stages:
      #call_calibrate: {}
      drift:
        input: lmsd
        detuning: 1
        factor: 1
        offset: -1
        outputs:
        - piezo
        time: 2
      lmsd:
        input: lmsd
        detuning: 1
        factor: 0.1
        time: 0.2
        outputs:
        - piezo
      call_setup_pll:
        timeout: 0.5
      #finish:  # problematic for lock acquisition
      #  input: lmsd
      #  detuning: 0
      #  factor: 0.1
      #  outputs:
      #  - piezo
  calibrate:
    zoomfactor: 0.1
    relative_threshold: 0.75
  #peak: 0.07061767578125
  peak_pdh: 0.1053466796875
  pll:
    # 4 principal feedback loops: frequency, angle, quadraturefactor, amplitude
    #above phasethreshold, frequency is incremented by f_jump
    f_phasethreshold: 25.0  # 25.0
    # the angle error times anglegain is added to the demodulation angle
    angle_gain: 1.0 #1.0
    # nominal phase for the demodulation angle
    f_phasesetpoint: 240.0
    # the quadraturefactor error is exponentiated by quadraturefactor_gain and
    # multiplied onto quadraturefactor
    quadraturefactor_gain: 1.0 #1.0
    # the amp error is exponentiated by amp_gain
    # amp error is the ratio of quadraturefactor and qf_setpoint
    amp_gain: 0.051 # 0.1
    # other stuff
    amp_dgain: 0.0 #0.0
    # amp_setpoint is the setpoint for the mean result from amp_natrace
    #this should be tuned after manually looking at the na trace with the
    #corresponding parameters
    amp_setpoint: 0.01 # 0.003  #0.1 #0.03  # 0.015
    # qf setpoint is the stable value for quadrature factor and should be
    # the same as at setup (giving a nice LMSD signal during sweeping)
    qf_setpoint: 0.05 #0.025

    amp_max: 0.35
    amp_min: 0.025
    f_jump: 0.015
    na_averages: 1000
    na_samples: 100 #1000
    amp_natrace:
      start: 689200  #689000
      stop: 689400  #689000
      rbw: [75, 75]
      points: 51
      amplitude: 0.25
      logscale: false
    #  avg: 1
    #amp_natrace:
    #  start: 688000
    #  stop: 690000
    #  rbw: [75, 75]
    #  points: 101
    #  amplitude: 0.1
    #  logscale: false
    #  avg: 1

# all signals that are inputs of the lockbox. Must be signal names understood
# by the model.
inputs:
  reflection:
    redpitaya_input: adc2
    offset: -0.011612139642238617
    max: 0.06178303807973862
    min: 0.017471514642238617
    mean: 0.055541761219501495
    rms: 0.004199783034511618
    curve: 256431
  pdh:
    redpitaya_input: adc1
    max: 0.10808976739645004
    min: -0.10260359197854996
    mean: -0.0013632923364639282
    rms: 0.01862275802942001
    setup:
      phase: -5
      amplitude: 4.0
      amplitude_for_finesse: 3.5
      frequency: 80000000.0
      generator: AFG_EVA
    offset: -0.011245273053646088
  lmsd:
    redpitaya_input: iq2
    peak: -0.7
    xmax: 11.370978376182121
    phi: 0
    offset: 0.0004473179578781128
    max: 0.3129346892237663
    min: -0.2935106232762337
    mean: -0.0035892650485038757
    rms: 0.07346427173403569
    curve: 256020
    variable_per_time: 6120.24734567
    setup:
      phase: 240
      amplitude: 0.25
      frequency: 3578312.838329047  #3578311.5236825133
      iq: iq2
      quadrature_factor: 0.2
      gain: 0
      output_direct: out2
      output_signal: quadrature
      input: adc2
      acbandwidth: 1000000.0
      bandwidth: [1000000.0, 1000000.0, 1000000.0, 1000000.0]
  lmsd_quadrature:
    redpitaya_input: adc1

    offset: -0.01122669130563736
# All output signals. Names of outputs are arbitrary. if the 'lock' tab is
# missing or false, the output will not be used for locking
outputs:
  # the very coarse piezo. at the moment, it is controlled manually
  slow:
    lock:
      skip: true
      unity_gain_frequency: 10.0
      inputfilter:
      - 0
      - 0
      - 0
      - 0
    redpitaya_output: pwm1
    # attention: output voltage is inversed w.r.t. redpitaya voltage because of
    # inverting amplifier behind pwm1
    max_voltage: 0.7
    min_voltage: -1.0
    # amplitier gain complicated - calibrate manually. at the moment
    # let's say 2V gives us a full FSR or better:
    # amplifier gain 100V/V, 1 micron/100V, penalty 6, in principle twice as
    # much cause 2 piezos are active
    m_per_V: 3.2e-07
    analogfilter:
      lowpass:
      - 0.05
    calibrationunits: m_per_V
    lastoffset: 0.5694580078125
  piezo:
    redpitaya_output: out2
    # we will calibrate the piezo response in units of m_per_V (not a necessary
    # parameter as it can be automatically filled in by the code)
    calibrationunits: m_per_V
    # piezo: PD080.31
    # piezo specification: 2 micron / 100 V
    # cryogenic penalty factor: 6
    # piezo amplifier gain: 1 V / V
    # therefore effective DC gain of piezo:
    # 3.1 nm / V
    # light is reflected from this mirror at 45 degrees
    # this decreases the effective displacement by a factor of sqrt(2) to 1.77
    m_per_V: 3.1e-09
    # PZT parallel capacity: 1 uF
    # Series resistance: 50 Ohm + 10 kOhm
    # RC cutoff 1/2piRC = 37.9 Hz
    # therefore the analog filter can be well approximated by a first order
    # lowpass with corner frequency 37.9 Hz
    analogfilter:
      lowpass: [15.8]
    lock:
      unity_gain_frequency: 100.0
      second_integrator_crossover: 5.0
      inputfilter:
      - 9714.04681957369
      - 9714.04681957369
      - 9714.04681957369
      - 9714.04681957369
      - 9714.04681957369
      - 9714.04681957369
      - 0
      - 0
    sweep:
      waveform: sin
      frequency: 25.0
      amplitude: 0.75
    max_voltage: 0.75
    min_voltage: -0.75
    transfer_function:
      open_loop: 254634
  fastpiezo:
    redpitaya_output: out1
    calibrationunits: m_per_V
    m_per_V: 3.0e-10
    # PZT parallel capacity: 1 uF
    # Series resistance: 50 Ohm + 10 kOhm
    # RC cutoff 1/2piRC = 37.9 Hz
    # therefore the analog filter can be well approximated by a first order
    # lowpass with corner frequency 37.9 Hz
    analogfilter:
      lowpass: []
    lock:
      #skip: true
      proportional_gain: 1.0e-10
      inputfilter:
      - 1000000.0
      - 1000000.0
    max_voltage: 0.9998779296875
    min_voltage: -1.0
    transfer_function:
      open_loop: 254744
    iir:
      inputfilter: -150
      loops: 200
      gain: 1.0
      plot: false
      zeros:
      - (-151.00000009999999-16271.516867390001j)
      - (-151.00000009999999+16271.516867390001j)
      - (-51.000000100000001-22342.54324816j)
      - (-51.000000100000001+22342.54324816j)
      - (-1.0000001000000001-30884.304061449999j)
      - (-1.0000001000000001+30884.304061449999j)
      - (-41.000000100000001-32732.524450659999j)
      - (-41.000000100000001+32732.524450659999j)
      - (-51.000000100000001-46953.00496993j)
      - (-51.000000100000001+46953.00496993j)
      poles:
      - (-151.0000001-10101.3614529j)
      - (-151.0000001+10101.3614529j)
      - (-81.0000001-21828.9081776j)
      - (-81.0000001+21828.9081776j)
      - (-1.0000001-30156.73583j)
      - (-1.0000001+30156.73583j)
      - (-1.0000001-32063.2533145j)
      - (-1.0000001+32063.2533145j)
      - (-61.0000001-44654.6352456j)
      - (-61.0000001+44654.6352456j)
      - (-100e3)

##############################################################################
###  Configuration parameters that rarely need to be modified ################
##############################################################################

scope:
  input1: iq2 #adc2
  input2: iq2_2 #dac2
  duration: 0.1
  trigger_source: immediately
  average: false

scopegui:
  coordinates:
  - -586
  - 452
  - 546
  - 438
  auto_run_continuous: true

signal:
  unit: V # can be any of m, Hz, V, raw, ... as long as unit_per_V is defined
  V_per_V: 1.0 # default unit is V
  raw_per_V: 8192.0 # raw units from the FPGA
  # minimum trace duration in seconds
  # be aware that this number affects both the sampling rate and the minimum
  # frequency that can be resolved. Usually, you want to keep duration as long
  # as you can stand to wait for new signal data, typically 10-100 ms.
  duration: 0.1
  # selects whether scope is to be used in average mode
  # false is strongly suggested for duration-independent estimation of rms
  # true is preferred only when we want to get an extremely good mean estimate
  average: false
  # if true, the signal.curve command automatically saves the data to CurveDB
  autosave: true
  # number of points per curve; also the number of points used for mean and rms
  points: 16384
  # default trigger source
  trigger_source: immediately
  # default trigger threshold and hysteresis
  threshold: 0
  hysteresis: 0.002
  # timeout determines the time interval within which we do not take another
  # data trace if several parameters are requested. To always obtain fresh
  # data, set this to -1. To enable manual acquisition control with the acquire
  # function '_acquire()', set this to a very large value or to '.inf'.
  acquire_timeout: 0.5
  # if true, the offset is subtraced. Calibrate with signal.get_offset()
  offset_subtraction: true
  offset: 0
  # peak is a reserved place to store the peak value, for example offresonant
  # reflection from a cavity
  peak: 0
  trigger_delay: 0

# fpm related stuff
constants:
  pdh_marker_frequency: 3600000.0
